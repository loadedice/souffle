/*
 * Souffle - A Datalog Compiler
 * Copyright (c) 2017, The Souffle Developers. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at:
 * - https://opensource.org/licenses/UPL
 * - <souffle root>/licenses/SOUFFLE-UPL.txt
 */

/************************************************************************
 *
 * @file MagicSet.cpp
 *
 * Define classes and functionality related to the magic set transformation.
 *
 ***********************************************************************/

#include "MagicSet.h"
#include "AstVisitor.h"
#include "Global.h"
#include "IODirectives.h"

namespace souffle {
/* general functions */

// checks whether the adorned version of two predicates is equal
bool isEqualAdornment(
        AstRelationIdentifier pred1, std::string adorn1, AstRelationIdentifier pred2, std::string adorn2) {
    if ((pred1 == pred2) && (adorn1.compare(adorn2) == 0)) {
        return true;
    }
    return false;
}

// checks whether an element is contained within a set
template <class T>
bool contains(std::set<T> set, T element) {
    if (set.find(element) != set.end()) {
        return true;
    }
    return false;
}

// checks whether a given adorned predicate is contained within a set
bool contains(std::set<AdornedPredicate> adornedPredicates, AstRelationIdentifier atomName,
        std::string atomAdornment) {
    for (AdornedPredicate seenPred : adornedPredicates) {
        if (isEqualAdornment(seenPred.getName(), seenPred.getAdornment(), atomName, atomAdornment)) {
            return true;
        }
    }
    return false;
}

// splits up a string into a set given a delimiter
std::set<std::string> split(std::string str, char delimiter) {
    std::set<std::string> res;
    int begin = 0;
    for (size_t i = 0; i < str.size(); i++) {
        if (str[i] == delimiter) {
            std::string token = str.substr(begin, (i - begin));
            res.insert(token);
            begin = i + 1;
        }
    }
    res.insert(str.substr(begin));  // add in the last remaining token
    res.erase("");                  // remove empty tokens
    return res;
}

// checks whether a string begins with a given string
bool hasPrefix(std::string str, std::string prefix) {
    if (str.substr(0, prefix.size()).compare(prefix) == 0) {
        return true;
    }
    return false;
}

// checks whether the given relation is generated by an aggregator
bool isAggRel(AstRelationIdentifier rel) {
    // TODO (azreika): this covers too much (e.g. user-defined __agg_rel_x)
    //                 need a way to determine if created by aggregates
    return hasPrefix(rel.getNames()[0], "__agg_rel_");
}

// gets the position of the final underscore in a given string
int getEndpoint(std::string mainName) {
    int endpt = mainName.size() - 1;
    while (endpt >= 0 && mainName[endpt] != '_') {
        endpt--;
    }
    if (endpt == -1) {
        endpt = mainName.size();
    }
    return endpt;
}

/* argument-related functions */

// returns the string representation of a given argument
std::string getString(AstArgument* arg) {
    std::stringstream argStream;
    argStream.str("");
    argStream << *arg;
    return argStream.str();
}

// checks whether a given atom has a bound argument
bool hasBoundArgument(AstAtom* atom, std::set<std::string> boundArgs) {
    for (AstArgument* arg : atom->getArguments()) {
        std::string name = getString(arg);
        if (boundArgs.find(name) != boundArgs.end()) {
            return true;  // found a bound argument, so can stop
        }
    }
    return false;
}

// checks whether the lhs is bound by a binary functor (and is not bound yet)
bool isBoundArg(AstArgument* lhs, AstArgument* rhs, std::set<std::string> boundArgs) {
    std::string lhs_name = getString(lhs);
    std::string rhs_name = getString(rhs);

    // only want to check variables we have not bound yet
    if (dynamic_cast<AstVariable*>(lhs) && (boundArgs.find(lhs_name) == boundArgs.end())) {
        // return true if the rhs is a bound variable or a constant
        if (dynamic_cast<AstVariable*>(rhs) && (boundArgs.find(rhs_name) != boundArgs.end())) {
            return true;
        } else if (dynamic_cast<AstConstant*>(rhs)) {
            return true;
        }
    }
    return false;
}

/* functor/aggregator check functions */

// checks whether an argument involves functors or aggregators
bool argumentContainsFunctorsOrAggs(AstArgument* arg) {
    if (dynamic_cast<AstFunctor*>(arg)) {
        // functor found!
        return true;
    } else if (dynamic_cast<AstRecordInit*>(arg)) {
        AstRecordInit* recordarg = dynamic_cast<AstRecordInit*>(arg);
        for (AstArgument* subarg : recordarg->getArguments()) {
            if (argumentContainsFunctorsOrAggs(subarg)) {
                return true;
            }
        }
    } else if (dynamic_cast<AstTypeCast*>(arg)) {
        AstTypeCast* typearg = dynamic_cast<AstTypeCast*>(arg);
        if (argumentContainsFunctorsOrAggs(typearg->getValue())) {
            return true;
        }
    } else if (dynamic_cast<AstAggregator*>(arg)) {
        // aggregator found!
        return true;
    }
    return false;
}

// checks whether an atom involves functors or aggregators
bool atomContainsFunctorsOrAggs(AstAtom* atom) {
    for (AstArgument* arg : atom->getArguments()) {
        if (argumentContainsFunctorsOrAggs(arg)) {
            return true;
        }
    }
    return false;
}

// checks whether a literal involves functors or aggregators
bool literalContainsFunctorsOrAggs(AstLiteral* lit) {
    if (dynamic_cast<AstAtom*>(lit)) {
        if (atomContainsFunctorsOrAggs(dynamic_cast<AstAtom*>(lit))) {
            return true;
        }
    } else if (dynamic_cast<AstNegation*>(lit)) {
        AstNegation* negLit = dynamic_cast<AstNegation*>(lit);
        if (atomContainsFunctorsOrAggs(negLit->getAtom())) {
            return true;
        }
    } else {
        AstConstraint* cons = dynamic_cast<AstConstraint*>(lit);
        if (argumentContainsFunctorsOrAggs(cons->getLHS()) ||
                argumentContainsFunctorsOrAggs(cons->getRHS())) {
            return true;
        }
    }
    return false;
}

// checks whether the clause contains functors or aggregators
bool containsFunctorsOrAggs(AstClause* clause) {
    if (atomContainsFunctorsOrAggs(clause->getHead())) {
        return true;
    }
    for (AstLiteral* lit : clause->getBodyLiterals()) {
        if (literalContainsFunctorsOrAggs(lit)) {
            return true;
        }
    }
    return false;
}

/* program-adding related functions */

// returns the new source location of a newly-created node
AstSrcLocation nextSrcLoc(AstSrcLocation orig) {
    static int pos = 0;
    pos += 1;

    AstSrcLocation newLoc;
    newLoc.filename = orig.filename + " [MAGIC_FILE]";
    newLoc.start.line = pos;
    newLoc.end.line = pos;
    newLoc.start.column = 0;
    newLoc.end.column = 1;

    return newLoc;
}

// returns the next available relation name prefixed by "newedb"
std::string getNextEdbName(AstProgram* program) {
    static int edbNum = 0;
    std::stringstream newEdbName;

    // find the next unused relation name of the form "newedbX", X an integer
    do {
        newEdbName.str("");  // check
        edbNum++;
        newEdbName << "newedb" << edbNum;
    } while (program->getRelation(newEdbName.str()) != nullptr);

    return newEdbName.str();
}

// copies over necessary qualifiers from original into new relation
// note that input/output directives are handled at the end of the MST
void updateQualifier(AstRelation* originalRelation, AstRelation* newRelation) {
    int currentQualifier = newRelation->getQualifier();

    if (originalRelation->isEqRel()) {
        currentQualifier |= EQREL_RELATION;
    }

    newRelation->setQualifier(currentQualifier);
}

// create a new relation with a given name based on a previous relation
AstRelation* createNewRelation(AstRelation* original, AstRelationIdentifier newName) {
    AstRelation* newRelation = new AstRelation();
    newRelation->setSrcLoc(nextSrcLoc(original->getSrcLoc()));
    newRelation->setName(newName);

    // copy over the attributes from the original relation
    for (AstAttribute* attr : original->getAttributes()) {
        newRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
    }

    // copy over necessary qualifiers
    updateQualifier(original, newRelation);

    return newRelation;
}

// returns the magic-set identifier corresponding to a given relation (mX_relation)
AstRelationIdentifier createMagicIdentifier(AstRelationIdentifier relationName, size_t outputNumber) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name to magic-relation format
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << "+m" << outputNumber << "_" << relationNames[0];  // use "+m" to avoid conflicts
    AstRelationIdentifier newRelationName(newMainName.str());

    // copy over the other relation names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the adorned identifier corresponding to a given relation and adornment (relationName_adornment)
AstRelationIdentifier createAdornedIdentifier(AstRelationIdentifier relationName, std::string adornment) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name
    std::stringstream newMainName;
    newMainName.str("");
    // add a '+' to avoid name conflict
    newMainName << relationNames[0] << "+_" << adornment;
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the other names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the requested substring of a given identifier
AstRelationIdentifier createSubIdentifier(AstRelationIdentifier relationName, size_t start, size_t length) {
    std::vector<std::string> relationNames = relationName.getNames();

    // get the substring of the base name
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << relationNames[0].substr(start, length);
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the remaining names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

/* functions to find atoms to ignore */

// add all atoms of an argument that contain aggregators to the ignored relations list
// ignoredNames - name of relations already ignored
std::set<AstRelationIdentifier> argumentAddAggregators(
        AstArgument* arg, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = ignoredNames;

    if (dynamic_cast<AstAggregator*>(arg)) {
        AstAggregator* aggregator = dynamic_cast<AstAggregator*>(arg);
        // aggregator found - add all atoms in body to ignored atoms list
        for (AstLiteral* lit : aggregator->getBodyLiterals()) {
            if (lit->getAtom() != nullptr) {
                retVal.insert(lit->getAtom()->getName());
            }
        }
    } else if (dynamic_cast<AstFunctor*>(arg)) {
        // if the argument is a functor, check each of its respective
        // arguments for aggregators
        if (dynamic_cast<AstUnaryFunctor*>(arg)) {
            AstUnaryFunctor* func = dynamic_cast<AstUnaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getOperand(), retVal);
        } else if (dynamic_cast<AstBinaryFunctor*>(arg)) {
            AstBinaryFunctor* func = dynamic_cast<AstBinaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getLHS(), retVal);
            retVal = argumentAddAggregators(func->getRHS(), retVal);
        } else if (dynamic_cast<AstTernaryFunctor*>(arg)) {
            AstTernaryFunctor* func = dynamic_cast<AstTernaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getArg(0), retVal);
            retVal = argumentAddAggregators(func->getArg(1), retVal);
            retVal = argumentAddAggregators(func->getArg(2), retVal);
        }
    } else if (dynamic_cast<AstRecordInit*>(arg)) {
        // if the argument is a record, check each of its own arguments for aggregators
        AstRecordInit* rec = dynamic_cast<AstRecordInit*>(arg);
        for (AstArgument* subarg : rec->getArguments()) {
            retVal = argumentAddAggregators(subarg, retVal);
        }
    } else if (dynamic_cast<AstTypeCast*>(arg)) {
        // if the argument is a typecast, check the subargument
        AstTypeCast* tcast = dynamic_cast<AstTypeCast*>(arg);
        retVal = argumentAddAggregators(tcast->getValue(), retVal);
    }

    return retVal;
}

// add all atoms of an atom that contain aggregators to the ignored relations list
std::set<AstRelationIdentifier> atomAddAggregators(
        AstAtom* atom, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = ignoredNames;
    for (AstArgument* arg : atom->getArguments()) {
        retVal = argumentAddAggregators(arg, retVal);
    }
    return retVal;
}

// add all atoms within a clause that contain aggregators to the ignored relations list
std::set<AstRelationIdentifier> addAggregators(
        AstClause* clause, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = ignoredNames;

    // check for aggregators in the head
    retVal = atomAddAggregators(clause->getHead(), retVal);

    // check for aggregators in the body literals
    for (AstLiteral* lit : clause->getBodyLiterals()) {
        if (dynamic_cast<AstAtom*>(lit)) {
            retVal = atomAddAggregators((AstAtom*)lit, retVal);
        } else if (dynamic_cast<AstNegation*>(lit)) {
            retVal = atomAddAggregators((AstAtom*)(lit->getAtom()), retVal);
        } else {
            AstConstraint* cons = dynamic_cast<AstConstraint*>(lit);
            retVal = argumentAddAggregators(cons->getLHS(), retVal);
            retVal = argumentAddAggregators(cons->getRHS(), retVal);
        }
    }
    return retVal;
}

// for a given set of relations, add in all the atoms in their rules
// TODO (azreika): can be done much more efficiently
std::set<AstRelationIdentifier> addDependencies(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    bool relationsAdded = false;
    std::set<AstRelationIdentifier> retVals;
    for (AstRelationIdentifier relName : relations) {
        retVals.insert(relName);  // add the relation itself

        for (AstClause* clause : program->getRelation(relName)->getClauses()) {
            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit) || dynamic_cast<AstNegation*>(lit)) {
                    AstRelationIdentifier addedName = lit->getAtom()->getName();
                    retVals.insert(addedName);
                    if (relations.find(addedName) == relations.end()) {
                        relationsAdded = true;
                    }
                }
            }
        }
    }

    if (relationsAdded) {
        return addDependencies(program, retVals);
    } else {
        return retVals;
    }
}

// ensures that every relation not specified by the magic-transform option
// is ignored by the transformation
std::set<AstRelationIdentifier> addIgnoredRelations(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    // get a set of all relations specified by the option
    std::set<std::string> specifiedRelations = split(Global::config().get("magic-transform"), ',');

    // if a star was used as a relation, then magic set will be performed for all nodes
    if (contains(specifiedRelations, "*")) {
        return relations;
    }

    std::set<AstRelationIdentifier> retVal(relations);
    for (AstRelation* rel : program->getRelations()) {
        // ignore all relations not specified by the option
        std::string mainName = rel->getName().getNames()[0];
        if (!contains(specifiedRelations, mainName)) {
            retVal.insert(rel->getName());
        }
    }

    return retVal;
}

/* =======================  *
 *        Adornment         *
 * =======================  */

// reorders a vector of integers to fit the clause atom-reordering function
std::vector<unsigned int> reorderOrdering(std::vector<unsigned int> order) {
    // when the adornment is computed, the atoms are numbered based on
    // which was chosen by the SIPS first - this is the 'order' vector.
    // want to reorder clause atoms so that the atom labelled 0 is first, and so on.
    // i.e. order[i] denotes where labels[i] should move
    // e.g.: [a, b, c] with label [1, 2, 0] should become [c, a, b]

    // the atom reordering function for clauses, however, moves it as follows:
    // [a, b, c] with label [1, 2, 0] becomes [b, c, a]
    // i.e. labels[i] goes to the position of i in the order vector

    // this function reorders the ordering scheme to match the second type
    std::vector<unsigned int> neworder(order.size());
    for (size_t i = 0; i < order.size(); i++) {
        // this took embarrassingly long to figure out
        neworder[order[i]] = i;
    }
    return neworder;
}

// reorders an adornment based on a given ordering scheme
std::vector<std::string> reorderAdornment(
        std::vector<std::string> adornment, std::vector<unsigned int> order) {
    // order[i] denotes where labels[i] should move
    // [a, b, c] with order [1, 2, 0] -> [c, a, b]
    std::vector<std::string> result(adornment.size());
    for (size_t i = 0; i < adornment.size(); i++) {
        result[order[i]] = adornment[i];
    }
    return result;
}

// computes the adornment of a newly chosen atom
// returns both the adornment and the new list of bound arguments
std::pair<std::string, std::set<std::string>> bindArguments(
        AstAtom* currAtom, std::set<std::string> boundArgs) {
    std::set<std::string> newlyBoundArgs;
    std::string atomAdornment = "";

    for (AstArgument* arg : currAtom->getArguments()) {
        std::string argName = getString(arg);
        if (boundArgs.find(argName) != boundArgs.end()) {
            atomAdornment += "b";  // bound
        } else {
            atomAdornment += "f";            // free
            newlyBoundArgs.insert(argName);  // now bound
        }
    }

    // add newly bound arguments to the list of bound arguments
    for (std::string newArg : newlyBoundArgs) {
        boundArgs.insert(newArg);
    }

    std::pair<std::string, std::set<std::string>> result;
    result.first = atomAdornment;
    result.second = boundArgs;
    return result;
}

// SIPS #1:
// Choose the left-most body atom with at least one bound argument
// If none exist, prioritise EDB predicates.
int getNextAtomNaiveSIPS(
        std::vector<AstAtom*> atoms, std::set<std::string> boundArgs, std::set<AstRelationIdentifier> edb) {
    // find the first available atom with at least one bound argument
    int firstedb = -1;
    int firstidb = -1;
    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        AstRelationIdentifier atomName = currAtom->getName();

        // check if this is the first edb or idb atom met
        if (contains(edb, atomName)) {
            if (firstedb < 0) {
                firstedb = i;
            }
        } else if (firstidb < 0) {
            firstidb = i;
        }

        // if it has at least one bound argument, then adorn this atom next
        if (hasBoundArgument(currAtom, boundArgs)) {
            return i;
        }
    }

    // all unadorned body atoms only have free arguments
    // choose the first edb remaining if available
    if (firstedb >= 0) {
        return firstedb;
    } else {
        return firstidb;
    }
}

// SIPS #2:
// Choose the body atom with the maximum number of bound arguments
// If equal boundness, prioritise left-most EDB
int getNextAtomMaxBoundSIPS(
        std::vector<AstAtom*>& atoms, std::set<std::string> boundArgs, std::set<AstRelationIdentifier> edb) {
    int maxBound = -1;
    int maxIndex = 0;
    bool maxIsEDB = false;  // checks if current max index is an EDB predicate

    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        int numBound = 0;
        for (AstArgument* arg : currAtom->getArguments()) {
            std::string name = getString(arg);
            if (boundArgs.find(name) != boundArgs.end()) {
                numBound++;  // found a bound argument
            }
        }

        if (numBound > maxBound) {
            maxBound = numBound;
            maxIndex = i;
            maxIsEDB = contains(edb, currAtom->getName());
        } else if (!maxIsEDB && numBound == maxBound && contains(edb, currAtom->getName())) {
            // prioritise EDB predicates
            maxIsEDB = true;
            maxIndex = i;
        }
    }

    return maxIndex;
}

// Choose the atom with the maximum ratio of bound arguments to total arguments
int getNextAtomMaxRatioSIPS(
        std::vector<AstAtom*>& atoms, std::set<std::string> boundArgs, std::set<AstRelationIdentifier> edb) {
    double maxRatio = -1;
    int maxIndex = 0;

    for (size_t i = 0; i < atoms.size(); i++) {
        AstAtom* currAtom = atoms[i];
        if (currAtom == nullptr) {
            // already done - move on
            continue;
        }

        int numArguments = currAtom->getArity();
        if (numArguments == 0) {
            return i;  // no arguments!
        }

        int numBound = 0;
        for (AstArgument* arg : currAtom->getArguments()) {
            std::string name = getString(arg);
            if (boundArgs.find(name) != boundArgs.end()) {
                numBound++;  // found a bound argument
            }
        }

        double currRatio = numBound * 1.0 / numArguments;

        if (currRatio == 1) {
            return i;  // all bound, not going to get better than this
        }

        if (currRatio > maxRatio) {
            maxRatio = currRatio;
            maxIndex = i;
        }
    }

    return maxIndex;
}

// Choose the SIP Strategy to be used
// Current choice is the max ratio SIPS
int getNextAtomSIPS(
        std::vector<AstAtom*>& atoms, std::set<std::string> boundArgs, std::set<AstRelationIdentifier> edb) {
    return getNextAtomMaxBoundSIPS(atoms, boundArgs, edb);
}

// runs the adornment algorithm on an input program
// Adornment algorithm:

// Let P be the set of all adorned predicates (initially empty)
// Let D' be the set of all adorned clauses (initially empty)
// Let S be the set of all seen predicate adornments

// Get the program
// Get the query
// Adorn the query based on boundness, and add it to P and S
// While P is not empty
// -- Pop the first atom out, call it R^c, where c is the adornment
// -- For every clause Q defining R:
// -- -- Adorn Q using R^c based on the SIPS chosen
// -- -- Add the adorned clause to D'
// -- -- If the body of the adorned clause contains an
//        unseen predicate adornment, add it to S and P

// Output: D' [the set of all adorned clauses]
void Adornment::run(const AstTranslationUnit& translationUnit) {
    // -------------
    // --- Setup ---
    // -------------
    const AstProgram* program = translationUnit.getProgram();

    // set up IDB/EDB and the output queries
    std::vector<AstRelationIdentifier> outputQueries;
    std::vector<std::vector<AdornedClause>> adornedProgram;

    // sort out the relations in the program into EDB/IDB and find computed relations
    for (AstRelation* rel : program->getRelations()) {
        AstRelationIdentifier relName = rel->getName();

        // find computed relations for the topdown part
        if (rel->isComputed()) {
            outputQueries.push_back(rel->getName());
            adornmentRelations.push_back(rel->getName());  // add relation to adornment
        }

        // check whether edb or idb
        bool is_edb = true;
        for (AstClause* clause : rel->getClauses()) {
            if (!clause->isFact()) {
                is_edb = false;
                break;
            }
        }

        if (is_edb) {
            adornmentEdb.insert(relName);
        } else {
            adornmentIdb.insert(relName);
        }
    }

    // find all negated literals
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstNegation*>(lit)) {
                    negatedAtoms.insert(lit->getAtom()->getName());
                }
            }
        }
    }

    // add the relations needed for negated relations to be computed
    negatedAtoms = addDependencies(program, negatedAtoms);

    // find atoms that should be ignored
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            // ignore atoms that have rules containing functors or aggregators
            if (containsFunctorsOrAggs(clause)) {
                ignoredAtoms.insert(clause->getHead()->getName());
            }

            // ignore all atoms used inside an aggregator within the clause
            ignoredAtoms = addAggregators(clause, ignoredAtoms);
        }
    }

    // find atoms that should be ignored based on magic-transform option
    ignoredAtoms = addIgnoredRelations(program, ignoredAtoms);
    ignoredAtoms = addDependencies(program, ignoredAtoms);

    // -----------------
    // --- Adornment ---
    // -----------------
    // begin adornment algorithm
    // adornment is performed for each output query separately
    for (size_t querynum = 0; querynum < outputQueries.size(); querynum++) {
        AstRelationIdentifier outputQuery = outputQueries[querynum];
        std::vector<AdornedPredicate> currentPredicates;
        std::set<AdornedPredicate> seenPredicates;
        std::vector<AdornedClause> adornedClauses;

        // create an adorned predicate of the form outputName_ff..f
        size_t arity = program->getRelation(outputQuery)->getArity();
        std::string frepeat = std::string(arity, 'f');  // #fs = #args
        AdornedPredicate outputPredicate(outputQuery, frepeat);
        currentPredicates.push_back(outputPredicate);
        seenPredicates.insert(outputPredicate);

        // keep going through the remaining predicates that need to be adorned
        while (!currentPredicates.empty()) {
            // pop out the first element
            AdornedPredicate currPredicate = currentPredicates[0];
            currentPredicates.erase(currentPredicates.begin());

            // go through and adorn all IDB clauses defining the relation
            AstRelation* rel = program->getRelation(currPredicate.getName());
            for (AstClause* clause : rel->getClauses()) {
                if (clause->isFact()) {
                    continue;
                }

                size_t numAtoms = clause->getAtoms().size();
                std::vector<std::string> clauseAtomAdornments(numAtoms);
                std::vector<unsigned int> ordering(numAtoms);
                std::set<std::string> boundArgs;

                // mark all bound arguments in the head as bound
                AstAtom* clauseHead = clause->getHead();
                std::string headAdornment = currPredicate.getAdornment();
                std::vector<AstArgument*> headArguments = clauseHead->getArguments();

                for (size_t argnum = 0; argnum < headArguments.size(); argnum++) {
                    if (headAdornment[argnum] == 'b') {
                        std::string name = getString(headArguments[argnum]);
                        boundArgs.insert(name);
                    }
                }

                // mark all bound arguments from the body
                std::vector<AstConstraint*> constraints = clause->getConstraints();

                for (size_t i = 0; i < constraints.size(); i++) {
                    AstConstraint* constraint = constraints[i];
                    BinaryConstraintOp op = constraint->getOperator();

                    if (op != BinaryConstraintOp::EQ) {
                        continue;
                    }

                    AstArgument* lhs = constraint->getLHS();
                    AstArgument* rhs = constraint->getRHS();
                    if (isBoundArg(lhs, rhs, boundArgs)) {
                        boundArgs.insert(getString(lhs));
                    }
                    if (isBoundArg(rhs, lhs, boundArgs)) {
                        boundArgs.insert(getString(rhs));
                    }
                }

                std::vector<AstAtom*> atoms = clause->getAtoms();
                int atomsAdorned = 0;
                int atomsTotal = atoms.size();

                while (atomsAdorned < atomsTotal) {
                    // get the next body atom to adorn based on our SIPS
                    int currIndex = getNextAtomSIPS(atoms, boundArgs, adornmentEdb);
                    AstAtom* currAtom = atoms[currIndex];
                    AstRelationIdentifier atomName = currAtom->getName();

                    // compute the adornment pattern of this atom, and
                    // add all its arguments to the list of bound args
                    std::pair<std::string, std::set<std::string>> result = bindArguments(currAtom, boundArgs);
                    std::string atomAdornment = result.first;
                    boundArgs = result.second;

                    // check if we've already dealt with this adornment before
                    if (!contains(seenPredicates, atomName, atomAdornment)) {
                        // not seen before, so push it onto the computation list
                        // and mark it as seen
                        currentPredicates.push_back(AdornedPredicate(atomName, atomAdornment));
                        seenPredicates.insert(AdornedPredicate(atomName, atomAdornment));
                    }

                    clauseAtomAdornments[currIndex] = atomAdornment;  // store the adornment
                    ordering[currIndex] = atomsAdorned;               // mark what atom number this is
                    atoms[currIndex] = nullptr;                       // mark as done

                    atomsAdorned++;
                }

                // adornment of this clause is complete - add it to the list of
                // adorned clauses
                adornedClauses.push_back(
                        AdornedClause(clause, headAdornment, clauseAtomAdornments, ordering));
            }
        }

        // add the list of adorned clauses matching the current output relation
        adornmentClauses.push_back(adornedClauses);
    }
}

// output the adornment analysis computed
// format: 'Output <outputNumber>: <outputName>' followed by a list of the
// related clause adornments, each on a new line
void Adornment::print(std::ostream& os) const {
    for (size_t i = 0; i < adornmentClauses.size(); i++) {
        std::vector<AdornedClause> clauses = adornmentClauses[i];
        os << "Output " << i + 1 << ": " << adornmentRelations[i] << std::endl;
        for (AdornedClause clause : clauses) {
            os << clause << std::endl;
        }
        os << std::endl;
    }
}

/* =======================  *
 * Magic Set Transformation *
 * =======================  */

// transforms the program so that a relation is either purely made up of
// facts or has no facts at all
void separateDBs(AstProgram* program) {
    for (AstRelation* relation : program->getRelations()) {
        AstRelationIdentifier relName = relation->getName();

        // determine whether the relation fits into the EDB, IDB, or both
        bool is_edb = false;
        bool is_idb = false;

        for (AstClause* clause : relation->getClauses()) {
            if (clause->isFact()) {
                is_edb = true;
            } else {
                is_idb = true;
            }
            if (is_edb && is_idb) {
                break;
            }
        }

        if (is_edb && is_idb) {
            // relation is part of EDB and IDB

            // move all the relation's facts to a new relation with a unique name
            std::string newEdbName = getNextEdbName(program);
            AstRelation* newEdbRel = createNewRelation(relation, newEdbName);
            program->appendRelation(std::unique_ptr<AstRelation>(newEdbRel));

            // find all facts for the relation
            for (AstClause* clause : relation->getClauses()) {
                if (clause->isFact()) {
                    // clause is fact - add it to the new EDB relation
                    AstClause* newEdbClause = clause->clone();
                    newEdbClause->getHead()->setName(newEdbName);
                    program->appendClause(std::unique_ptr<AstClause>(newEdbClause));
                }
            }

            // add a rule to the old relation that relates it to the new relation
            AstClause* newIdbClause = new AstClause();
            newIdbClause->setSrcLoc(nextSrcLoc(relation->getSrcLoc()));

            // oldname(arg1...argn) :- newname(arg1...argn)
            AstAtom* headAtom = new AstAtom(relName);
            AstAtom* bodyAtom = new AstAtom(newEdbName);

            size_t numargs = relation->getArity();
            for (size_t j = 0; j < numargs; j++) {
                std::stringstream argName;
                argName.str("");
                argName << "arg" << j;
                headAtom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
                bodyAtom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
            }

            newIdbClause->setHead(std::unique_ptr<AstAtom>(headAtom));
            newIdbClause->addToBody(std::unique_ptr<AstAtom>(bodyAtom));

            program->appendClause(std::unique_ptr<AstClause>(newIdbClause));
        }
    }
}

// returns the adornment of an (adorned) magic identifier
std::string extractAdornment(AstRelationIdentifier magicRelationName) {
    std::string baseRelationName = magicRelationName.getNames()[0];
    int endpt = getEndpoint(baseRelationName);
    std::string adornment = baseRelationName.substr(endpt + 1, baseRelationName.size() - (endpt + 1));
    return adornment;
}

// transforms the program so that all underscores previously transformed
// to a "+underscoreX" are changed back to underscores
void replaceUnderscores(AstProgram* program) {
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            // create a new clause for the final result
            AstClause* newClause = clause->cloneHead();

            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit) == 0) {
                    // all non-atoms added immediately
                    newClause->addToBody(std::unique_ptr<AstLiteral>(lit->clone()));
                    continue;
                }

                AstAtom* newLit = lit->getAtom()->clone();
                std::vector<AstArgument*> args = newLit->getArguments();
                for (size_t argNum = 0; argNum < args.size(); argNum++) {
                    AstArgument* currArg = args[argNum];

                    // find all variables beginning with "+underscore" and
                    // replace them with actual underscores
                    if (dynamic_cast<const AstVariable*>(currArg)) {
                        AstVariable* var = (AstVariable*)currArg;
                        if (hasPrefix(var->getName(), "+underscore")) {
                            newLit->setArgument(
                                    argNum, std::unique_ptr<AstArgument>(new AstUnnamedVariable()));
                        }
                    }
                }

                // add the fixed atom to the body
                newClause->addToBody(std::unique_ptr<AstLiteral>(newLit));
            }

            // remove the old clause and add the fixed one
            rel->removeClause(clause);
            rel->addClause(std::unique_ptr<AstClause>(newClause));
        }
    }
}

// Magic Set Transformation
// STEPS:
// For all output relations G:
// -- Get the adornment S for this clause
// -- Add to S the set of magic rules for all clauses in S:
// -- -- For each clause C = A^a :- A1^a1, A2^a2, ..., An^an
// -- -- -- For each IDB literal A_i in the body of C
// -- -- -- -- Add mag(Ai^ai) :- mag(A^a), A1^a1, ..., Ai-1^ai-1 to the program
// -- For all clauses H :- T in S:
// -- -- Replace the clause with H :- mag(H), T.
// -- Add the fact m_G_f...f to S
// Remove all old idb rules
bool MagicSetTransformer::transform(AstTranslationUnit& translationUnit) {
    AstProgram* program = translationUnit.getProgram();

    separateDBs(program);  // make EDB int IDB = empty

    Adornment* adornment = translationUnit.getAnalysis<Adornment>();  // perform adornment

    // edb/idb handling
    std::vector<std::vector<AdornedClause>> allAdornedClauses = adornment->getAdornedClauses();
    std::set<AstRelationIdentifier> negatedAtoms = adornment->getNegatedAtoms();
    std::set<AstRelationIdentifier> ignoredAtoms = adornment->getIgnoredAtoms();
    std::set<AstRelationIdentifier> oldIdb = adornment->getIDB();
    std::set<AstRelationIdentifier> newIdb;

    // additions
    std::vector<AstRelationIdentifier> newQueryNames;
    std::vector<AstClause*> newClauses;

    // output handling
    std::vector<AstRelationIdentifier> outputQueries = adornment->getRelations();
    std::set<AstRelationIdentifier> addAsOutput;
    std::set<AstRelationIdentifier> addAsPrintSize;
    std::map<AstRelationIdentifier, std::vector<AstIODirective*>> outputDirectives;

    // perform magic set algorithm for each output
    for (size_t querynum = 0; querynum < outputQueries.size(); querynum++) {
        AstRelationIdentifier outputQuery = outputQueries[querynum];
        std::vector<AdornedClause> adornedClauses = allAdornedClauses[querynum];
        AstRelation* originalOutputRelation = program->getRelation(outputQuery);

        // add a relation for the output query
        // mN_outputname_ff...f()
        AstRelation* magicOutputRelation = new AstRelation();
        std::string frepeat = std::string(originalOutputRelation->getArity(), 'f');
        AstRelationIdentifier magicOutputName =
                createMagicIdentifier(createAdornedIdentifier(outputQuery, frepeat), querynum);
        magicOutputRelation->setName(magicOutputName);
        newQueryNames.push_back(magicOutputName);

        // add the new relation to the program
        program->appendRelation(std::unique_ptr<AstRelation>(magicOutputRelation));

        // add an empty fact to the program
        // i.e. mN_outputname_ff...f().
        AstClause* outputFact = new AstClause();
        outputFact->setSrcLoc(nextSrcLoc(originalOutputRelation->getSrcLoc()));
        outputFact->setHead(std::unique_ptr<AstAtom>(new AstAtom(magicOutputName)));
        program->appendClause(std::unique_ptr<AstClause>(outputFact));

        // perform the magic transformation based on the adornment for this output query
        for (AdornedClause adornedClause : adornedClauses) {
            AstClause* clause = adornedClause.getClause();
            AstRelationIdentifier originalName = clause->getHead()->getName();

            // dont perform the magic transformation on ignored relations
            if (contains(ignoredAtoms, originalName)) {
                continue;
            }

            // find the adorned version of this relation
            std::string headAdornment = adornedClause.getHeadAdornment();
            AstRelationIdentifier newRelName = createAdornedIdentifier(originalName, headAdornment);
            AstRelation* adornedRelation = program->getRelation(newRelName);

            // check if adorned relation already created previously
            if (adornedRelation == nullptr) {
                // adorned relation not created yet, so
                // create the relation with the new adornment
                AstRelation* originalRelation = program->getRelation(originalName);
                AstRelation* newRelation = createNewRelation(originalRelation, newRelName);

                // copy over input directives to new adorned relation
                // also - update input directives to correctly use default fact file names
                if (originalRelation->isInput()) {
                    IODirectives inputDirectives;  // to more easily work with the directive
                    AstIODirective* newDirective = new AstIODirective();
                    inputDirectives.setRelationName(newRelName.getNames()[0]);
                    newDirective->addName(newRelName);
                    newDirective->setAsInput();
                    for (AstIODirective* current : originalRelation->getIODirectives()) {
                        if (current->isInput()) {
                            for (const auto& currentPair : current->getIODirectiveMap()) {
                                newDirective->addKVP(currentPair.first, currentPair.second);
                                inputDirectives.set(currentPair.first, currentPair.second);
                            }
                        }
                    }
                    if (!inputDirectives.has("IO")) {
                        inputDirectives.setIOType("file");
                        newDirective->addKVP("IO", "file");
                    }
                    if (inputDirectives.getIOType() == "file" && !inputDirectives.has("filename")) {
                        newDirective->addKVP("filename", originalName.getNames()[0] + ".facts");
                    }

                    newRelation->addIODirectives(std::unique_ptr<AstIODirective>(newDirective));
                }

                // add the created adorned relation to the program
                program->appendRelation(std::unique_ptr<AstRelation>(newRelation));
                adornedRelation = newRelation;
            }

            // create the adorned version of this clause
            AstClause* newClause = clause->clone();
            newClause->getHead()->setName(newRelName);
            // reorder atoms based on SIPS ordering
            newClause->reorderAtoms(reorderOrdering(adornedClause.getOrdering()));

            // get corresponding adornments for each body atom
            std::vector<std::string> bodyAdornment =
                    reorderAdornment(adornedClause.getBodyAdornment(), adornedClause.getOrdering());

            // set the name of each IDB pred in the clause to be the adorned version
            int atomsSeen = 0;
            for (AstLiteral* lit : newClause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit)) {
                    AstAtom* bodyAtom = dynamic_cast<AstAtom*>(lit);
                    AstRelationIdentifier atomName = bodyAtom->getName();
                    // note that all atoms in the original clause were adorned,
                    // but only the IDB atom adornments should be added here
                    if (contains(oldIdb, atomName)) {
                        if (!contains(ignoredAtoms, atomName)) {
                            // ignored atoms should not be changed
                            AstRelationIdentifier newAtomName =
                                    createAdornedIdentifier(atomName, bodyAdornment[atomsSeen]);
                            bodyAtom->setName(newAtomName);
                            newIdb.insert(newAtomName);
                        } else {
                            newIdb.insert(atomName);
                        }
                    }
                    atomsSeen++;
                }
            }

            // Add the set of magic rules for this clause C = A^a :- A1^a1, A2^a2, ..., An^an
            // -- For each clause C = A^a :- A1^a1, A2^a2, ..., An^an
            // -- -- For each IDB literal A_i in the body of C
            // -- -- -- Add mag(Ai^ai) :- mag(A^a), A1^a1, ..., Ai-1^ai-1 to the program
            std::vector<AstLiteral*> body = newClause->getBodyLiterals();
            for (size_t i = 0; i < body.size(); i++) {
                AstLiteral* currentLiteral = body[i];

                // only care about atoms in the body
                if (dynamic_cast<AstAtom*>(currentLiteral)) {
                    AstAtom* atom = dynamic_cast<AstAtom*>(currentLiteral);
                    AstRelationIdentifier atomName = atom->getName();

                    // only IDB atoms that are not being ignored matter
                    if (contains(newIdb, atomName) && !contains(ignoredAtoms, atomName)) {
                        std::string currAdornment = bodyAdornment[i];

                        // generate the name of the magic version of this adorned literal
                        AstRelationIdentifier newAtomName = createMagicIdentifier(atomName, querynum);

                        // if the magic version does not exist, create it
                        if (program->getRelation(newAtomName) == nullptr) {
                            AstRelation* magicRelation = new AstRelation();
                            magicRelation->setName(newAtomName);

                            // find out the original name of the relation (pre-adornment)
                            std::string baseAtomName = atomName.getNames()[0];
                            int endpt = getEndpoint(baseAtomName);
                            AstRelationIdentifier originalRelationName = createSubIdentifier(
                                    atomName, 0, endpt - 1);  // get rid of the extra + at the end
                            AstRelation* originalRelation = program->getRelation(originalRelationName);

                            // copy over the (bound) attributes from the original relation
                            int argcount = 0;
                            for (AstAttribute* attr : originalRelation->getAttributes()) {
                                if (currAdornment[argcount] == 'b') {
                                    magicRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
                                }
                                argcount++;
                            }

                            // add in relevant qualifiers from original relation
                            updateQualifier(originalRelation, magicRelation);

                            // add the new magic relation to the program
                            program->appendRelation(std::unique_ptr<AstRelation>(magicRelation));
                        }

                        // start setting up the magic rule
                        AstClause* magicClause = new AstClause();
                        magicClause->setSrcLoc(nextSrcLoc(atom->getSrcLoc()));

                        // create the head of the magic rule
                        AstAtom* magicHead = new AstAtom(newAtomName);

                        // copy over (bound) arguments from the original atom
                        int argCount = 0;
                        for (AstArgument* arg : atom->getArguments()) {
                            if (currAdornment[argCount] == 'b') {
                                magicHead->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        // head complete!
                        magicClause->setHead(std::unique_ptr<AstAtom>(magicHead));

                        // -- create the body --
                        // create the first body argument (mag(origClauseHead^adornment))
                        AstRelationIdentifier magPredName =
                                createMagicIdentifier(newClause->getHead()->getName(), querynum);
                        AstAtom* addedMagicPred = new AstAtom(magPredName);

                        // create the relation if it does not exist
                        if (program->getRelation(magPredName) == nullptr) {
                            // get the adornment of this argument
                            std::string adornment = extractAdornment(magPredName);

                            // create the relation
                            AstRelation* newMagRelation = new AstRelation();
                            newMagRelation->setName(magPredName);

                            // copy over (bound) attributes from the original relation
                            AstRelation* currentRelation =
                                    program->getRelation(newClause->getHead()->getName());
                            std::vector<AstAttribute*> attrs = currentRelation->getAttributes();
                            for (size_t currentArg = 0; currentArg < currentRelation->getArity();
                                    currentArg++) {
                                if (adornment[currentArg] == 'b') {
                                    newMagRelation->addAttribute(
                                            std::unique_ptr<AstAttribute>(attrs[currentArg]->clone()));
                                }
                            }

                            // add the new relation to the prgoram
                            program->appendRelation(std::unique_ptr<AstRelation>(newMagRelation));
                        }

                        // add (bound) arguments to the magic predicate from the clause head
                        argCount = 0;
                        for (AstArgument* arg : newClause->getHead()->getArguments()) {
                            if (headAdornment[argCount] == 'b') {
                                addedMagicPred->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        // first argument complete!
                        magicClause->addToBody(std::unique_ptr<AstAtom>(addedMagicPred));

                        // add the rest of the necessary arguments
                        for (size_t j = 0; j < i; j++) {
                            magicClause->addToBody(std::unique_ptr<AstLiteral>(body[j]->clone()));
                        }

                        // go through the arguments in the head and bind the bound variables using constraints
                        std::vector<AstArgument*> currArguments = magicClause->getHead()->getArguments();
                        for (AstArgument* arg : currArguments) {
                            std::string argName = getString(arg);

                            // all bound arguments begin with "+abdul" (see AstTransforms.cpp)
                            // +abdulX_variablevalue_s
                            if (hasPrefix(argName, "+abdul")) {
                                // -- check if string or num constant --

                                // strip off the prefix up to (and including) the first underscore
                                size_t argStart = argName.find('_');
                                std::string res = argName.substr(argStart + 1, argName.size());

                                AstArgument* newArgument;
                                if (res[res.size() - 1] == 's') {
                                    // string argument
                                    std::string str = res.substr(0, res.size() - 2);
                                    newArgument = new AstStringConstant(
                                            translationUnit.getSymbolTable(), str.c_str());
                                } else {
                                    // numeric argument
                                    size_t argEnd = argName.find('_', argStart + 1);
                                    std::string startstr =
                                            argName.substr(argStart + 1, argEnd - argStart - 1);
                                    newArgument = new AstNumberConstant(stoi(startstr));
                                }

                                // add the constraint to the body of the clause
                                AstConstraint* newConstraint = new AstConstraint(BinaryConstraintOp::EQ,
                                        std::unique_ptr<AstArgument>(arg->clone()),
                                        std::unique_ptr<AstArgument>(newArgument));
                                magicClause->addToBody(std::unique_ptr<AstLiteral>(newConstraint));
                            }
                        }

                        // magic rule done! add it to the program
                        program->appendClause(std::unique_ptr<AstClause>(magicClause));
                    }
                }
            }

            // -- replace with H :- mag(H), T --

            size_t originalNumAtoms = newClause->getAtoms().size();

            // create the first argument of this new clause
            const AstAtom* newClauseHead = newClause->getHead()->getAtom();
            AstRelationIdentifier newMag = createMagicIdentifier(newClauseHead->getName(), querynum);
            AstAtom* newMagAtom = new AstAtom(newMag);

            // copy over the bound arguments from the head
            std::vector<AstArgument*> args = newClauseHead->getArguments();
            for (size_t k = 0; k < args.size(); k++) {
                if (headAdornment[k] == 'b') {
                    newMagAtom->addArgument(std::unique_ptr<AstArgument>(args[k]->clone()));
                }
            }

            // add it to the end of the clause
            newClause->addToBody(std::unique_ptr<AstAtom>(newMagAtom));

            // move the new magic argument to the front of the clause,
            // pushing all the rest up one position
            std::vector<unsigned int> newClauseOrder(originalNumAtoms + 1);
            for (size_t k = 0; k < originalNumAtoms; k++) {
                newClauseOrder[k] = k + 1;
            }
            newClauseOrder[originalNumAtoms] = 0;
            newClause->reorderAtoms(reorderOrdering(newClauseOrder));

            // add the clause to the program and the set of new clauses
            newClause->setSrcLoc(nextSrcLoc(newClause->getSrcLoc()));
            newClauses.push_back(newClause);
            adornedRelation->addClause(std::unique_ptr<AstClause>(newClause));
        }
    }

    // remove all transformed old IDB relations, making sure to preserve input/output directives
    for (AstRelationIdentifier relationName : oldIdb) {
        AstRelation* relation = program->getRelation(relationName);

        // before deleting, store the directives of computed relations
        // for restoration later on
        if (relation->isOutput()) {
            addAsOutput.insert(relationName);
            std::vector<AstIODirective*> clonedDirectives;
            for (AstIODirective* iodir : relation->getIODirectives()) {
                clonedDirectives.push_back(iodir->clone());
            }
            outputDirectives[relationName] = clonedDirectives;
        } else if (relation->isPrintSize()) {
            addAsPrintSize.insert(relationName);
            std::vector<AstIODirective*> clonedDirectives;
            for (AstIODirective* iodir : relation->getIODirectives()) {
                clonedDirectives.push_back(iodir->clone());
            }
            outputDirectives[relationName] = clonedDirectives;
        }

        // do not delete negated atoms, ignored atoms, or atoms added by aggregate relations
        if (!(contains(ignoredAtoms, relationName) || contains(negatedAtoms, relationName) ||
                    isAggRel(relationName))) {
            program->removeRelation(relationName);
        }
    }

    // add the new output relations
    // in particular, need to rename the adorned output back to the original name
    for (size_t i = 0; i < outputQueries.size(); i++) {
        AstRelationIdentifier oldName = outputQueries[i];
        AstRelationIdentifier newName = newQueryNames[i];

        // get the original adorned relation
        std::string newBaseName = newName.getNames()[0];
        size_t prefixpoint = newBaseName.find("_");
        AstRelationIdentifier newRelationName =
                createSubIdentifier(newName, prefixpoint + 1, newBaseName.size() - (prefixpoint + 1));

        AstRelation* adornedRelation = program->getRelation(newRelationName);

        if (adornedRelation == nullptr) {
            continue;
        }

        AstRelation* outputRelation = program->getRelation(oldName);

        // if the corresponding output relation does not exist yet, create it
        if (outputRelation == nullptr) {
            outputRelation = new AstRelation();
            outputRelation->setSrcLoc(nextSrcLoc(adornedRelation->getSrcLoc()));

            // copy over the attributes from the existing adorned version
            for (AstAttribute* attr : adornedRelation->getAttributes()) {
                outputRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
            }

            // rename it back to its original name
            outputRelation->setName(oldName);

            // set as output relation
            AstIODirective* newdir = new AstIODirective();
            if (addAsOutput.find(oldName) != addAsOutput.end()) {
                newdir->setAsOutput();
            } else {
                newdir->setAsPrintSize();
            }
            outputRelation->addIODirectives(std::unique_ptr<AstIODirective>(newdir));

            // add the new output to the program
            program->appendRelation(std::unique_ptr<AstRelation>(outputRelation));
        }

        // rules need to be the same
        // easy fix:
        //    oldname(arg1...argn) :- newname(arg1...argn)
        AstAtom* headatom = new AstAtom(oldName);
        AstAtom* bodyatom = new AstAtom(newRelationName);

        for (size_t j = 0; j < adornedRelation->getArity(); j++) {
            std::stringstream argName;
            argName.str("");
            argName << "arg" << j;
            headatom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
            bodyatom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
        }

        // add the clause to the program
        AstClause* referringClause = new AstClause();
        referringClause->setSrcLoc(nextSrcLoc(outputRelation->getSrcLoc()));
        referringClause->setHead(std::unique_ptr<AstAtom>(headatom));
        referringClause->addToBody(std::unique_ptr<AstAtom>(bodyatom));

        program->appendClause(std::unique_ptr<AstClause>(referringClause));
    }

    // add in all the output directives to their corresponding relations
    for (std::pair<AstRelationIdentifier, std::vector<AstIODirective*>> iopair : outputDirectives) {
        for (AstIODirective* iodir : iopair.second) {
            program->getRelation(iopair.first)->addIODirectives(std::unique_ptr<AstIODirective>(iodir));
        }
    }

    // replace all "+underscoreX" variables with actual underscores
    replaceUnderscores(program);

    // done!
    return true;
}
}  // end of namespace souffle
